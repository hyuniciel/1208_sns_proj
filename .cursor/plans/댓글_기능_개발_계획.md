# 댓글 기능 개발 계획

## 개요

Instagram 스타일의 댓글 기능을 구현합니다. 사용자가 게시물에 댓글을 작성하고 삭제할 수 있으며, PostCard에서는 최신 2개만 미리보기로 표시됩니다.

## 1. API Route 생성: 댓글 작성/삭제

### 1.1 `app/api/comments/route.ts` 생성

**기능:**
- POST: 댓글 작성
- DELETE: 댓글 삭제 (본인만)
- 인증 검증 (Clerk)
- 댓글 목록 조회 (GET, 선택적)

**구현 세부사항:**

#### POST 핸들러 (댓글 작성)

1. **인증 확인**
   - Clerk `auth()`로 현재 사용자 확인
   - 인증되지 않은 경우 401 반환

2. **요청 본문 파싱**
   - `post_id`: 댓글을 작성할 게시물 ID (UUID)
   - `content`: 댓글 내용 (필수, 최소 1자, 최대 길이 제한 없음)
   - 필수 필드 검증

3. **사용자 ID 조회**
   - Clerk `userId`로 Supabase `users` 테이블에서 사용자 UUID 조회
   - 사용자가 존재하지 않으면 404 반환

4. **게시물 존재 확인**
   - `posts` 테이블에서 `post_id` 확인
   - 존재하지 않으면 404 반환

5. **댓글 내용 검증**
   - 빈 문자열 또는 공백만 있는 경우 400 반환
   - `trim()` 후 길이 확인

6. **댓글 저장**
   - `comments` 테이블에 레코드 삽입
   - `post_id`, `user_id`, `content` 저장
   - `created_at`, `updated_at` 자동 설정

7. **응답 반환**
   ```typescript
   {
     success: true,
     comment: {
       id: string,
       post_id: string,
       user_id: string,
       content: string,
       created_at: string,
       updated_at: string
     }
   }
   ```

#### DELETE 핸들러 (댓글 삭제)

1. **인증 확인**
   - Clerk `auth()`로 현재 사용자 확인
   - 인증되지 않은 경우 401 반환

2. **요청 본문 파싱**
   - `comment_id`: 삭제할 댓글 ID (UUID)
   - 필수 필드 검증

3. **사용자 ID 조회**
   - Clerk `userId`로 Supabase `users` 테이블에서 사용자 UUID 조회

4. **댓글 소유권 확인**
   - `comments` 테이블에서 댓글 조회
   - 존재하지 않으면 404 반환
   - `user_id`가 현재 사용자와 일치하지 않으면 403 Forbidden 반환

5. **댓글 삭제**
   - `comments` 테이블에서 댓글 삭제
   - CASCADE로 인해 자동 처리됨

6. **응답 반환**
   ```typescript
   {
     success: true,
     message: "Comment deleted"
   }
   ```

#### GET 핸들러 (댓글 목록 조회, 선택적)

1. **쿼리 파라미터 파싱**
   - `post_id`: 게시물 ID (필수)
   - `limit`: 가져올 댓글 수 (기본값: 50)
   - `offset`: 건너뛸 댓글 수 (기본값: 0)

2. **댓글 목록 조회**
   - `comments` 테이블과 `users` 테이블 JOIN
   - `post_id`로 필터링
   - `created_at DESC` 정렬 (최신순)
   - `limit`과 `offset`으로 페이지네이션

3. **응답 반환**
   ```typescript
   {
     comments: CommentWithUser[],
     total: number
   }
   ```

**코드 구조:**
```typescript
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import { createClerkSupabaseClient } from "@/lib/supabase/server";
import type { Comment, CommentWithUser } from "@/lib/types";

export async function POST(request: NextRequest) {
  try {
    // 1. 인증 확인
    // 2. 요청 본문 파싱
    // 3. 사용자 ID 조회
    // 4. 게시물 존재 확인
    // 5. 댓글 내용 검증
    // 6. 댓글 저장
    // 7. 응답 반환
  } catch (error) {
    // 에러 처리
  }
}

export async function DELETE(request: NextRequest) {
  try {
    // 1. 인증 확인
    // 2. 요청 본문 파싱
    // 3. 사용자 ID 조회
    // 4. 댓글 소유권 확인
    // 5. 댓글 삭제
    // 6. 응답 반환
  } catch (error) {
    // 에러 처리
  }
}

export async function GET(request: NextRequest) {
  try {
    // 1. 쿼리 파라미터 파싱
    // 2. 댓글 목록 조회
    // 3. 응답 반환
  } catch (error) {
    // 에러 처리
  }
}
```

**에러 처리:**
- 인증 실패: 401 Unauthorized
- 게시물/댓글/사용자 없음: 404 Not Found
- 권한 없음 (삭제): 403 Forbidden
- 잘못된 요청: 400 Bad Request
- 데이터베이스 에러: 500 Internal Server Error

## 2. CommentForm 컴포넌트

### 2.1 `components/comment/CommentForm.tsx` 생성

**기능:**
- 댓글 입력 필드 ("댓글 달기..." placeholder)
- Enter 키 또는 "게시" 버튼으로 제출
- 로딩 상태 관리
- 에러 처리
- 입력 후 자동 초기화

**Props 타입:**
```typescript
interface CommentFormProps {
  postId: string;
  onSubmit?: (comment: CommentWithUser) => void; // 성공 시 콜백
  placeholder?: string; // 기본값: "댓글 달기..."
  autoFocus?: boolean; // 자동 포커스
  onFocus?: () => void; // 포커스 시 콜백
}
```

**상태 관리:**
- `content`: 댓글 내용
- `isSubmitting`: 제출 중 상태
- `error`: 에러 메시지

**구현 세부사항:**

1. **입력 필드**
   - Textarea 또는 Input 컴포넌트 사용
   - Placeholder: "댓글 달기..."
   - 자동 높이 조절 (선택적)
   - Enter 키로 제출 (Shift+Enter는 줄바꿈)

2. **제출 버튼**
   - 입력이 비어있으면 비활성화
   - "게시" 텍스트 또는 아이콘만 표시
   - 로딩 중 스피너 표시

3. **Enter 키 처리**
   - Enter 키 누르면 제출
   - Shift+Enter는 줄바꿈
   - 모바일에서는 "게시" 버튼만 사용

4. **제출 처리**
   - API 호출 (`/api/comments` POST)
   - 성공 시 입력 초기화
   - `onSubmit` 콜백 호출
   - 에러 발생 시 에러 메시지 표시

**코드 구조:**
```typescript
'use client';

import { useState, useRef, KeyboardEvent } from 'react';
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import { Send, Loader2 } from 'lucide-react';
import { useUser } from '@clerk/nextjs';
import type { CommentWithUser } from '@/lib/types';

interface CommentFormProps {
  postId: string;
  onSubmit?: (comment: CommentWithUser) => void;
  placeholder?: string;
  autoFocus?: boolean;
}

export default function CommentForm({
  postId,
  onSubmit,
  placeholder = '댓글 달기...',
  autoFocus = false,
}: CommentFormProps) {
  const { user } = useUser();
  const [content, setContent] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  const handleSubmit = async () => {
    if (!content.trim() || isSubmitting) return;

    try {
      setIsSubmitting(true);
      setError(null);

      const response = await fetch('/api/comments', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          post_id: postId,
          content: content.trim(),
        }),
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || '댓글 작성에 실패했습니다.');
      }

      const data = await response.json();
      setContent('');
      onSubmit?.(data.comment);
    } catch (err) {
      setError(err instanceof Error ? err.message : '댓글 작성에 실패했습니다.');
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleKeyDown = (e: KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSubmit();
    }
  };

  return (
    <div className="flex items-center gap-2 px-4 py-3 border-t border-border">
      {/* 프로필 이미지 (선택적) */}
      <div className="flex-1">
        <Textarea
          ref={textareaRef}
          value={content}
          onChange={(e) => setContent(e.target.value)}
          onKeyDown={handleKeyDown}
          placeholder={placeholder}
          autoFocus={autoFocus}
          className="resize-none min-h-[40px] max-h-[120px]"
          disabled={isSubmitting}
        />
        {error && (
          <p className="text-sm text-red-500 mt-1">{error}</p>
        )}
      </div>
      <Button
        onClick={handleSubmit}
        disabled={!content.trim() || isSubmitting}
        size="sm"
        variant="ghost"
      >
        {isSubmitting ? (
          <Loader2 className="w-4 h-4 animate-spin" />
        ) : (
          <span className="text-instagram-blue font-semibold">게시</span>
        )}
      </Button>
    </div>
  );
}
```

**스타일링:**
- 입력 필드: 전체 너비, 최소 높이 40px, 최대 높이 120px
- 버튼: 우측 정렬, Instagram Blue 색상
- 에러 메시지: 빨간색, 작은 폰트

## 3. CommentList 컴포넌트

### 3.1 `components/comment/CommentList.tsx` 생성

**기능:**
- 댓글 목록 렌더링
- PostCard: 최신 2개만 표시
- 상세 모달: 전체 댓글 + 스크롤
- 삭제 버튼 (본인만 표시)
- 사용자 정보 표시
- 상대 시간 표시

**Props 타입:**
```typescript
interface CommentListProps {
  postId: string;
  comments: CommentWithUser[];
  maxVisible?: number; // 최대 표시 개수 (기본값: undefined, 전체 표시)
  showAllLink?: boolean; // "모두 보기" 링크 표시 여부
  onCommentDelete?: (commentId: string) => void; // 삭제 시 콜백
  currentUserId?: string; // 현재 사용자 ID (삭제 버튼 표시용)
  onShowAll?: () => void; // "모두 보기" 클릭 시 콜백
}
```

**구현 세부사항:**

1. **댓글 렌더링**
   - `comments` 배열을 순회하며 각 댓글 표시
   - `maxVisible`이 있으면 해당 개수만 표시
   - 사용자명 Bold + 댓글 내용

2. **삭제 버튼**
   - 본인 댓글만 표시 (`currentUserId`와 `comment.user_id` 비교)
   - ⋯ 메뉴 또는 삭제 아이콘
   - 클릭 시 확인 다이얼로그 (선택적)
   - 삭제 API 호출 (`/api/comments` DELETE)

3. **"모두 보기" 링크**
   - `maxVisible`이 있고 전체 댓글 수가 더 많을 때 표시
   - 클릭 시 `onShowAll` 콜백 호출 (상세 모달 열기)

4. **상대 시간 표시**
   - `formatRelativeTime` 함수 사용
   - 예: "3분 전", "1시간 전", "2일 전"

5. **사용자 정보**
   - 프로필 이미지 (32px 원형, 선택적)
   - 사용자명 (Bold, 클릭 시 프로필 페이지로 이동)

**코드 구조:**
```typescript
'use client';

import { useState } from 'react';
import { MoreHorizontal, Trash2 } from 'lucide-react';
import { Button } from '@/components/ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { formatRelativeTime } from '@/lib/utils/time';
import type { CommentWithUser } from '@/lib/types';

interface CommentListProps {
  postId: string;
  comments: CommentWithUser[];
  maxVisible?: number;
  showAllLink?: boolean;
  onCommentDelete?: (commentId: string) => void;
  currentUserId?: string;
  onShowAll?: () => void;
}

export default function CommentList({
  postId,
  comments,
  maxVisible,
  showAllLink = true,
  onCommentDelete,
  currentUserId,
  onShowAll,
}: CommentListProps) {
  const [deletingId, setDeletingId] = useState<string | null>(null);

  const visibleComments = maxVisible
    ? comments.slice(0, maxVisible)
    : comments;

  const hasMore = maxVisible && comments.length > maxVisible;

  const handleDelete = async (commentId: string) => {
    if (!confirm('댓글을 삭제하시겠습니까?')) return;

    try {
      setDeletingId(commentId);
      const response = await fetch('/api/comments', {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ comment_id: commentId }),
      });

      if (!response.ok) {
        throw new Error('댓글 삭제에 실패했습니다.');
      }

      onCommentDelete?.(commentId);
    } catch (error) {
      alert(error instanceof Error ? error.message : '댓글 삭제에 실패했습니다.');
    } finally {
      setDeletingId(null);
    }
  };

  if (comments.length === 0) {
    return null;
  }

  return (
    <div className="px-4 space-y-2">
      {hasMore && showAllLink && (
        <button
          onClick={onShowAll}
          className="text-text-secondary text-sm hover:text-text-primary"
        >
          댓글 {comments.length}개 모두 보기
        </button>
      )}

      {visibleComments.map((comment) => (
        <div key={comment.id} className="flex items-start gap-2 group">
          <div className="flex-1">
            <div className="flex items-baseline gap-2">
              <span className="font-bold text-text-primary text-sm">
                {comment.user.name}
              </span>
              <span className="text-text-primary text-sm">
                {comment.content}
              </span>
            </div>
            <span className="text-text-secondary text-xs">
              {formatRelativeTime(comment.created_at)}
            </span>
          </div>

          {currentUserId === comment.user_id && (
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button
                  variant="ghost"
                  size="sm"
                  className="opacity-0 group-hover:opacity-100 transition-opacity"
                >
                  <MoreHorizontal className="w-4 h-4" />
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent>
                <DropdownMenuItem
                  onClick={() => handleDelete(comment.id)}
                  disabled={deletingId === comment.id}
                  className="text-red-500"
                >
                  <Trash2 className="w-4 h-4 mr-2" />
                  삭제
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          )}
        </div>
      ))}
    </div>
  );
}
```

**스타일링:**
- 댓글 간격: `space-y-2`
- 사용자명: Bold, Instagram 텍스트 색상
- 시간: 작은 폰트, 회색
- 삭제 버튼: Hover 시에만 표시 (`opacity-0 group-hover:opacity-100`)

## 4. PostCard에 댓글 기능 통합

### 4.1 `components/post/PostCard.tsx` 업데이트

**변경 사항:**

1. **댓글 상태 관리**
   - `comments` 상태 추가
   - `commentsCount` 상태 추가
   - 초기값: `post.comments_count` 및 빈 배열

2. **댓글 목록 로드**
   - 컴포넌트 마운트 시 또는 필요 시 댓글 목록 로드
   - `/api/comments?post_id={postId}&limit=2` 호출
   - 최신 2개만 가져오기

3. **CommentList 통합**
   - CommentList 컴포넌트 추가
   - `maxVisible={2}` prop 전달
   - `showAllLink={true}` prop 전달
   - `onShowAll` 콜백으로 상세 모달 열기 (나중에 구현)

4. **CommentForm 통합**
   - CommentForm 컴포넌트 추가
   - `onSubmit` 콜백으로 댓글 목록 업데이트
   - 댓글 작성 성공 시 목록 새로고침

5. **댓글 수 업데이트**
   - 댓글 작성 시 `commentsCount` 증가
   - 댓글 삭제 시 `commentsCount` 감소

**코드 구조:**
```typescript
'use client';

import { useState, useEffect } from 'react';
import CommentList from '@/components/comment/CommentList';
import CommentForm from '@/components/comment/CommentForm';
import type { PostWithUser, CommentWithUser } from '@/lib/types';

interface PostCardProps {
  post: PostWithUser;
  currentUserId?: string;
}

export default function PostCard({ post, currentUserId }: PostCardProps) {
  const [comments, setComments] = useState<CommentWithUser[]>([]);
  const [commentsCount, setCommentsCount] = useState(post.comments_count);

  // 댓글 목록 로드
  useEffect(() => {
    const loadComments = async () => {
      try {
        const response = await fetch(
          `/api/comments?post_id=${post.id}&limit=2`
        );
        if (response.ok) {
          const data = await response.json();
          setComments(data.comments || []);
        }
      } catch (error) {
        console.error('Failed to load comments:', error);
      }
    };

    loadComments();
  }, [post.id]);

  const handleCommentSubmit = (comment: CommentWithUser) => {
    setComments((prev) => [comment, ...prev].slice(0, 2));
    setCommentsCount((prev) => prev + 1);
  };

  const handleCommentDelete = (commentId: string) => {
    setComments((prev) => prev.filter((c) => c.id !== commentId));
    setCommentsCount((prev) => Math.max(0, prev - 1));
  };

  const handleShowAll = () => {
    // 상세 모달 열기 (나중에 구현)
    console.log('Show all comments for post:', post.id);
  };

  return (
    <div className="bg-card-background border border-border rounded-lg">
      {/* 헤더 */}
      {/* 이미지 */}
      {/* 액션 버튼 */}
      {/* 좋아요 수 */}
      {/* 캡션 */}

      {/* 댓글 목록 */}
      <CommentList
        postId={post.id}
        comments={comments}
        maxVisible={2}
        showAllLink={commentsCount > 2}
        onCommentDelete={handleCommentDelete}
        currentUserId={currentUserId}
        onShowAll={handleShowAll}
      />

      {/* 댓글 입력 폼 */}
      <CommentForm
        postId={post.id}
        onSubmit={handleCommentSubmit}
      />
    </div>
  );
}
```

## 5. 댓글 API 호출 유틸리티 (선택적)

### 5.1 `lib/api/comments.ts` 생성 (선택적)

**기능:**
- 댓글 작성/삭제 API 호출 함수
- 에러 처리 및 타입 안정성

**구현:**
```typescript
import type { ApiResponse, CommentWithUser } from '@/lib/types';

export async function createComment(
  postId: string,
  content: string
): Promise<ApiResponse<CommentWithUser>> {
  try {
    const response = await fetch('/api/comments', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        post_id: postId,
        content,
      }),
    });

    if (!response.ok) {
      const error = await response.json();
      return { data: null, error: error.error || 'Failed to create comment' };
    }

    const data = await response.json();
    return { data: data.comment, error: null };
  } catch (error) {
    return { data: null, error: 'Network error' };
  }
}

export async function deleteComment(
  commentId: string
): Promise<ApiResponse<void>> {
  try {
    const response = await fetch('/api/comments', {
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ comment_id: commentId }),
    });

    if (!response.ok) {
      const error = await response.json();
      return { data: null, error: error.error || 'Failed to delete comment' };
    }

    return { data: undefined, error: null };
  } catch (error) {
    return { data: null, error: 'Network error' };
  }
}

export async function getComments(
  postId: string,
  limit?: number,
  offset?: number
): Promise<ApiResponse<CommentWithUser[]>> {
  try {
    const params = new URLSearchParams({
      post_id: postId,
    });
    if (limit) params.append('limit', limit.toString());
    if (offset) params.append('offset', offset.toString());

    const response = await fetch(`/api/comments?${params}`);

    if (!response.ok) {
      const error = await response.json();
      return { data: null, error: error.error || 'Failed to fetch comments' };
    }

    const data = await response.json();
    return { data: data.comments || [], error: null };
  } catch (error) {
    return { data: null, error: 'Network error' };
  }
}
```

## 6. 상대 시간 유틸리티

### 6.1 `lib/utils/time.ts` 확인/생성

**기능:**
- 상대 시간 포맷팅 함수
- 댓글 작성 시간 표시용

**구현:**
```typescript
export function formatRelativeTime(dateString: string): string {
  const date = new Date(dateString);
  const now = new Date();
  const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);

  if (diffInSeconds < 60) return '방금 전';
  if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}분 전`;
  if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}시간 전`;
  if (diffInSeconds < 604800) return `${Math.floor(diffInSeconds / 86400)}일 전`;
  if (diffInSeconds < 2592000) return `${Math.floor(diffInSeconds / 604800)}주 전`;
  return `${Math.floor(diffInSeconds / 2592000)}개월 전`;
}
```

## 7. 에러 핸들링

### 7.1 클라이언트 에러 처리

1. **댓글 작성 에러**
   - 빈 댓글: 입력 필드에 에러 메시지 표시
   - 네트워크 에러: "댓글 작성에 실패했습니다. 다시 시도해주세요."
   - 인증 에러 (401): 로그인 페이지로 리다이렉트

2. **댓글 삭제 에러**
   - 권한 없음 (403): "댓글을 삭제할 권한이 없습니다."
   - 네트워크 에러: "댓글 삭제에 실패했습니다."
   - 확인 다이얼로그로 실수 방지

3. **댓글 목록 로드 에러**
   - 에러 발생 시 빈 배열 표시
   - 사용자에게 에러 메시지 표시 (선택적)

### 7.2 서버 에러 처리

1. **댓글 작성 실패**
   - 에러 로그 기록
   - 사용자에게 명확한 에러 메시지 반환

2. **댓글 삭제 실패**
   - 소유권 확인 실패 시 403 반환
   - 에러 로그 기록

## 작업 순서

1. **API Route 생성** (1단계)
   - `app/api/comments/route.ts` 생성
   - POST 핸들러 구현 (댓글 작성)
   - DELETE 핸들러 구현 (댓글 삭제)
   - GET 핸들러 구현 (선택적, 댓글 목록 조회)
   - 인증 및 에러 처리
   - 테스트

2. **CommentForm 컴포넌트 생성** (2단계)
   - `components/comment/CommentForm.tsx` 생성
   - 입력 필드 구현
   - Enter 키 처리
   - 제출 버튼 구현
   - API 호출 통합

3. **CommentList 컴포넌트 생성** (3단계)
   - `components/comment/CommentList.tsx` 생성
   - 댓글 목록 렌더링
   - 삭제 버튼 구현
   - "모두 보기" 링크 구현

4. **PostCard 통합** (4단계)
   - CommentList를 PostCard에 추가
   - CommentForm을 PostCard에 추가
   - 댓글 상태 관리
   - 댓글 수 업데이트

5. **스타일링 및 다듬기** (5단계)
   - Instagram 디자인에 맞게 스타일 조정
   - 반응형 확인
   - 애니메이션 추가 (선택적)

## 참고 파일

- [docs/PRD.md](docs/PRD.md) - 댓글 기능 정의 (285-291줄, 125-127줄)
- [docs/TODO.md](docs/TODO.md) - 댓글 기능 TODO (118-134줄)
- [supabase/migrations/db.sql](supabase/migrations/db.sql) - comments 테이블 스키마 (88-114줄)
- [lib/types.ts](lib/types.ts) - TypeScript 타입 정의 (Comment, CommentWithUser)
- [lib/supabase/server.ts](lib/supabase/server.ts) - Supabase 서버 클라이언트
- [.cursor/plans/홈_피드_페이지_개발_계획.md](.cursor/plans/홈_피드_페이지_개발_계획.md) - PostCard 구조 참고

## 주의사항

1. **댓글 내용 검증**: 빈 문자열 및 공백만 있는 경우 방지
2. **삭제 권한**: 본인 댓글만 삭제 가능하도록 확인
3. **댓글 수 동기화**: 작성/삭제 시 댓글 수 실시간 업데이트
4. **성능**: PostCard에서는 최신 2개만 로드하여 성능 최적화
5. **에러 처리**: 사용자 친화적 에러 메시지 및 롤백 로직 필수
6. **인증**: 모든 API 호출에서 Clerk 인증 확인 필수
7. **상대 시간**: 한국어로 표시 ("3분 전", "1시간 전" 등)
8. **Enter 키 처리**: Shift+Enter는 줄바꿈, Enter는 제출
9. **삭제 확인**: 실수 방지를 위한 확인 다이얼로그 권장

