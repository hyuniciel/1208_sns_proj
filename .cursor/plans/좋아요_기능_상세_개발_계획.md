# 좋아요 기능 상세 개발 계획

## 개요

Instagram 스타일의 좋아요 기능을 구현합니다. 사용자가 게시물에 좋아요를 추가/제거할 수 있으며, 클릭 애니메이션과 더블탭 좋아요 기능을 포함합니다.

**참고 문서:**
- [PRD.md](../docs/PRD.md) - 좋아요 기능 정의 (278-283줄, 313-327줄)
- [db.sql](../../supabase/migrations/db.sql) - likes 테이블 스키마 (63-86줄)
- [TODO.md](../docs/TODO.md) - 좋아요 기능 TODO (87-99줄)

**현재 상태:**
- ✅ `likes` 테이블 생성 완료 (DB 스키마)
- ✅ `post_stats` 뷰에 `likes_count` 포함
- ✅ `app/api/posts/route.ts`에서 `is_liked` 상태 조회 완료
- ✅ `PostCard.tsx`에 좋아요 버튼 UI 존재 (기능 미구현)
- ❌ `app/api/likes/route.ts` 미구현
- ❌ `LikeButton.tsx` 컴포넌트 미구현
- ❌ 클릭 애니메이션 미구현
- ❌ 더블탭 좋아요 미구현

---

## 1. API Route 생성: 좋아요 추가/제거

### 1.1 `app/api/likes/route.ts` 생성

**파일 경로:** `app/api/likes/route.ts`

**기능:**
- POST: 좋아요 추가
- DELETE: 좋아요 제거
- 인증 검증 (Clerk)
- 중복 좋아요 방지 (DB 제약조건 활용)
- 에러 핸들링 및 로깅

**구현 세부사항:**

#### POST 핸들러 (좋아요 추가)

1. **인증 확인**
   - Clerk `auth()`로 현재 사용자 확인
   - 인증되지 않은 경우 401 반환

2. **요청 본문 파싱**
   - `post_id`: 좋아요를 추가할 게시물 ID (UUID)
   - 필수 필드 검증 (존재 여부, UUID 형식)

3. **사용자 ID 조회**
   - Clerk `userId`로 Supabase `users` 테이블에서 사용자 UUID 조회
   - `createClerkSupabaseClient()` 사용 (서버 사이드)
   - 사용자가 존재하지 않으면 404 반환

4. **게시물 존재 확인**
   - `posts` 테이블에서 `post_id` 확인
   - 존재하지 않으면 404 반환

5. **중복 좋아요 확인 (선택적)**
   - `likes` 테이블에서 `(post_id, user_id)` 조합 확인
   - 이미 좋아요가 있으면 409 Conflict 반환
   - 또는 DB 제약조건에 맡기고 에러 처리

6. **좋아요 추가**
   - `likes` 테이블에 레코드 삽입
   - DB 제약조건 (`UNIQUE(post_id, user_id)`)으로 중복 방지
   - 에러 처리: 23505 (unique_violation) → 이미 좋아요한 경우

7. **응답 반환**
   ```typescript
   {
     success: true,
     like: {
       id: string,
       post_id: string,
       user_id: string,
       created_at: string
     }
   }
   ```

#### DELETE 핸들러 (좋아요 제거)

1. **인증 확인**
   - Clerk `auth()`로 현재 사용자 확인
   - 인증되지 않은 경우 401 반환

2. **요청 본문 파싱**
   - `post_id`: 좋아요를 제거할 게시물 ID (UUID)
   - 필수 필드 검증

3. **사용자 ID 조회**
   - Clerk `userId`로 Supabase `users` 테이블에서 사용자 UUID 조회

4. **좋아요 제거**
   - `likes` 테이블에서 `(post_id, user_id)` 조합으로 삭제
   - `.delete().eq().eq()` 사용
   - 존재하지 않으면 404 반환 (또는 무시하고 성공 반환)

5. **응답 반환**
   ```typescript
   {
     success: true,
     message: "Like removed"
   }
   ```

**코드 구조:**
```typescript
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import { createClerkSupabaseClient } from "@/lib/supabase/server";
import type { Like } from "@/lib/types";

export async function POST(request: NextRequest) {
  try {
    console.group("POST /api/likes");
    
    // 1. 인증 확인
    const { userId: clerkUserId } = await auth();
    if (!clerkUserId) {
      return NextResponse.json(
        { error: "Unauthorized" },
        { status: 401 }
      );
    }

    // 2. 요청 본문 파싱
    const body = await request.json();
    const { post_id } = body;
    
    if (!post_id || typeof post_id !== 'string') {
      return NextResponse.json(
        { error: "post_id is required" },
        { status: 400 }
      );
    }

    // 3. Supabase 클라이언트 생성
    const supabase = createClerkSupabaseClient();

    // 4. 현재 사용자 UUID 조회
    const { data: currentUser, error: userError } = await supabase
      .from("users")
      .select("id")
      .eq("clerk_id", clerkUserId)
      .single();

    if (userError || !currentUser) {
      return NextResponse.json(
        { error: "User not found" },
        { status: 404 }
      );
    }

    // 5. 게시물 존재 확인
    const { data: post, error: postError } = await supabase
      .from("posts")
      .select("id")
      .eq("id", post_id)
      .single();

    if (postError || !post) {
      return NextResponse.json(
        { error: "Post not found" },
        { status: 404 }
      );
    }

    // 6. 좋아요 추가
    const { data: like, error: likeError } = await supabase
      .from("likes")
      .insert({
        post_id,
        user_id: currentUser.id,
      })
      .select()
      .single();

    if (likeError) {
      // 중복 좋아요 에러 처리
      if (likeError.code === '23505') {
        return NextResponse.json(
          { error: "Already liked" },
          { status: 409 }
        );
      }
      
      console.error("❌ 좋아요 추가 실패:", likeError);
      return NextResponse.json(
        { error: "Failed to add like", details: likeError.message },
        { status: 500 }
      );
    }

    console.log("✅ 좋아요 추가 완료:", like.id);
    console.groupEnd();

    return NextResponse.json({
      success: true,
      like,
    });
  } catch (error) {
    console.error("❌ POST /api/likes 에러:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

export async function DELETE(request: NextRequest) {
  try {
    console.group("DELETE /api/likes");
    
    // 1. 인증 확인
    const { userId: clerkUserId } = await auth();
    if (!clerkUserId) {
      return NextResponse.json(
        { error: "Unauthorized" },
        { status: 401 }
      );
    }

    // 2. 요청 본문 파싱
    const body = await request.json();
    const { post_id } = body;
    
    if (!post_id || typeof post_id !== 'string') {
      return NextResponse.json(
        { error: "post_id is required" },
        { status: 400 }
      );
    }

    // 3. Supabase 클라이언트 생성
    const supabase = createClerkSupabaseClient();

    // 4. 현재 사용자 UUID 조회
    const { data: currentUser, error: userError } = await supabase
      .from("users")
      .select("id")
      .eq("clerk_id", clerkUserId)
      .single();

    if (userError || !currentUser) {
      return NextResponse.json(
        { error: "User not found" },
        { status: 404 }
      );
    }

    // 5. 좋아요 제거
    const { error: deleteError } = await supabase
      .from("likes")
      .delete()
      .eq("post_id", post_id)
      .eq("user_id", currentUser.id);

    if (deleteError) {
      console.error("❌ 좋아요 제거 실패:", deleteError);
      return NextResponse.json(
        { error: "Failed to remove like", details: deleteError.message },
        { status: 500 }
      );
    }

    console.log("✅ 좋아요 제거 완료");
    console.groupEnd();

    return NextResponse.json({
      success: true,
      message: "Like removed",
    });
  } catch (error) {
    console.error("❌ DELETE /api/likes 에러:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
```

**테스트 시나리오:**
1. ✅ 인증되지 않은 사용자 → 401
2. ✅ 잘못된 post_id → 400 또는 404
3. ✅ 존재하지 않는 게시물 → 404
4. ✅ 중복 좋아요 → 409
5. ✅ 정상 좋아요 추가 → 200
6. ✅ 정상 좋아요 제거 → 200

---

## 2. LikeButton 컴포넌트 생성

### 2.1 `components/post/LikeButton.tsx` 생성

**파일 경로:** `components/post/LikeButton.tsx`

**기능:**
- 빈 하트 ↔ 빨간 하트 상태 관리
- 클릭 애니메이션 (scale 1.3 → 1, 0.15초)
- 더블탭 좋아요 (모바일, 큰 하트 fade in/out, 1초)
- API 호출 및 상태 업데이트
- Optimistic Update (즉시 UI 업데이트, 실패 시 롤백)
- 로딩 상태 관리

**Props 타입:**
```typescript
interface LikeButtonProps {
  postId: string;
  initialLiked: boolean;
  initialLikesCount: number;
  onLikeChange?: (liked: boolean, newCount: number) => void;
  size?: "sm" | "md" | "lg"; // 아이콘 크기
  enableDoubleTap?: boolean; // 더블탭 활성화 여부 (모바일)
  className?: string;
}
```

**상태 관리:**
- `liked`: 현재 좋아요 상태
- `likesCount`: 좋아요 수
- `isAnimating`: 클릭 애니메이션 중인지
- `isDoubleTapAnimating`: 더블탭 애니메이션 중인지
- `isLoading`: API 호출 중인지

**구현 세부사항:**

1. **하트 아이콘**
   - `liked` 상태에 따라 `Heart` (빈) 또는 `Heart` (채워진) 표시
   - 빨간색: `#ed4956` (`--like` 변수 또는 `fill-like text-like`)
   - 크기: 기본 24px (w-6 h-6), props로 조정 가능

2. **클릭 핸들러**
   - Optimistic Update: 클릭 시 즉시 UI 업데이트
   - API 호출 (`/api/likes` POST 또는 DELETE)
   - 성공 시 상태 유지, 실패 시 롤백

3. **클릭 애니메이션**
   - 클릭 시 `scale(1.3)` → `scale(1)` (0.15초)
   - CSS transition 사용: `transition-transform duration-150`
   - `isAnimating` 상태로 애니메이션 중 중복 클릭 방지

4. **더블탭 좋아요 (모바일)**
   - 이미지 영역에서 더블탭 감지 (PostCard에서 처리)
   - 큰 하트 아이콘 표시 (중앙, 80px)
   - `fade in` (0.2초) → `fade out` (0.8초)
   - 애니메이션 중에는 클릭 이벤트 무시

5. **로딩 상태**
   - API 호출 중에는 버튼 비활성화 또는 스피너 표시
   - 에러 발생 시 토스트 메시지 (선택적)

**코드 구조:**
```typescript
'use client';

import { useState, useCallback } from 'react';
import { Heart } from 'lucide-react';
import { cn } from '@/lib/utils';

interface LikeButtonProps {
  postId: string;
  initialLiked: boolean;
  initialLikesCount: number;
  onLikeChange?: (liked: boolean, newCount: number) => void;
  size?: "sm" | "md" | "lg";
  enableDoubleTap?: boolean;
  className?: string;
}

export default function LikeButton({
  postId,
  initialLiked,
  initialLikesCount,
  onLikeChange,
  size = 'md',
  enableDoubleTap = false,
  className,
}: LikeButtonProps) {
  const [liked, setLiked] = useState(initialLiked);
  const [likesCount, setLikesCount] = useState(initialLikesCount);
  const [isAnimating, setIsAnimating] = useState(false);
  const [isDoubleTapAnimating, setIsDoubleTapAnimating] = useState(false);
  const [isLoading, setIsLoading] = useState(false);

  const handleClick = useCallback(async () => {
    if (isLoading || isAnimating) return;

    // Optimistic Update
    const previousLiked = liked;
    const previousCount = likesCount;
    const newLiked = !liked;
    const newCount = newLiked ? likesCount + 1 : likesCount - 1;

    setLiked(newLiked);
    setLikesCount(newCount);
    setIsAnimating(true);
    setIsLoading(true);

    // 애니메이션 트리거
    setTimeout(() => setIsAnimating(false), 150);

    try {
      const response = await fetch('/api/likes', {
        method: newLiked ? 'POST' : 'DELETE',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ post_id: postId }),
      });

      if (!response.ok) {
        // 롤백
        setLiked(previousLiked);
        setLikesCount(previousCount);
        const error = await response.json();
        console.error('좋아요 실패:', error);
        return;
      }

      // 성공 시 콜백 호출
      if (onLikeChange) {
        onLikeChange(newLiked, newCount);
      }
    } catch (error) {
      // 롤백
      setLiked(previousLiked);
      setLikesCount(previousCount);
      console.error('좋아요 에러:', error);
    } finally {
      setIsLoading(false);
    }
  }, [postId, liked, likesCount, isLoading, isAnimating, onLikeChange]);

  const handleDoubleTap = useCallback(async () => {
    if (isLoading || isDoubleTapAnimating || liked) return;

    setIsDoubleTapAnimating(true);
    
    // 좋아요 추가
    await handleClick();

    // 애니메이션 종료
    setTimeout(() => setIsDoubleTapAnimating(false), 1000);
  }, [liked, isLoading, isDoubleTapAnimating, handleClick]);

  // 외부에서 더블탭 트리거할 수 있도록 expose
  // (PostCard에서 사용)

  const sizeClasses = {
    sm: 'w-5 h-5',
    md: 'w-6 h-6',
    lg: 'w-8 h-8',
  };

  return (
    <button
      onClick={handleClick}
      disabled={isLoading}
      className={cn(
        "transition-transform duration-150",
        isAnimating && "scale-[1.3]",
        className
      )}
      aria-label={liked ? "좋아요 취소" : "좋아요"}
    >
      <Heart
        className={cn(
          sizeClasses[size],
          "transition-colors",
          liked ? 'fill-like text-like' : 'text-text-primary'
        )}
      />
    </button>
  );
}

// 더블탭 애니메이션 컴포넌트 (PostCard에서 사용)
export function DoubleTapHeart({ isAnimating }: { isAnimating: boolean }) {
  return (
    <div
      className={cn(
        "absolute inset-0 flex items-center justify-center pointer-events-none z-10",
        "transition-opacity duration-200",
        isAnimating ? "opacity-100" : "opacity-0"
      )}
    >
      <Heart className="w-20 h-20 fill-like text-like" />
    </div>
  );
}
```

**스타일링:**
- 클릭 애니메이션: `transition-transform duration-150`
- 더블탭 애니메이션: `transition-opacity duration-200` (fade in), `duration-800` (fade out)
- 호버 효과: `hover:opacity-80`
- 비활성화: `disabled:opacity-50 disabled:cursor-not-allowed`

---

## 3. PostCard에 LikeButton 통합

### 3.1 `components/post/PostCard.tsx` 업데이트

**변경 사항:**

1. **LikeButton import 및 사용**
   - 기존 하트 버튼을 `LikeButton` 컴포넌트로 교체
   - `post.is_liked`, `post.likes_count` 전달

2. **더블탭 좋아요 구현**
   - 이미지 영역에 더블탭 이벤트 리스너 추가
   - `DoubleTapHeart` 컴포넌트 추가
   - 모바일에서만 활성화 (선택적)

3. **좋아요 수 업데이트**
   - `onLikeChange` 콜백으로 좋아요 수 실시간 업데이트
   - PostCard 내부 상태 업데이트

**코드 변경 예시:**
```typescript
// PostCard.tsx에 추가
import LikeButton, { DoubleTapHeart } from './LikeButton';

// 상태 추가
const [likesCount, setLikesCount] = useState(post.likes_count);
const [isLiked, setIsLiked] = useState(post.is_liked);
const [isDoubleTapAnimating, setIsDoubleTapAnimating] = useState(false);

// 더블탭 핸들러
const handleDoubleTap = useCallback(() => {
  if (isLiked) return;
  
  setIsDoubleTapAnimating(true);
  // LikeButton의 handleDoubleTap 호출
  setTimeout(() => setIsDoubleTapAnimating(false), 1000);
}, [isLiked]);

// 이미지 영역에 더블탭 이벤트 추가
<div 
  className="w-full aspect-square relative bg-gray-100"
  onDoubleClick={handleDoubleTap}
>
  <Image ... />
  <DoubleTapHeart isAnimating={isDoubleTapAnimating} />
</div>

// LikeButton으로 교체
<LikeButton
  postId={post.id}
  initialLiked={isLiked}
  initialLikesCount={likesCount}
  onLikeChange={(liked, newCount) => {
    setIsLiked(liked);
    setLikesCount(newCount);
  }}
  size="md"
/>
```

---

## 4. PostFeed 상태 업데이트

### 4.1 `components/post/PostFeed.tsx` 업데이트

**변경 사항:**

1. **좋아요 상태 업데이트 핸들러**
   - PostCard의 `onLikeChange` 콜백 처리
   - `posts` 배열에서 해당 게시물 찾아서 업데이트

2. **상태 동기화**
   - LikeButton의 상태 변경 시 PostFeed의 `posts` 상태 업데이트
   - 다른 PostCard에도 동일한 게시물이 있으면 동기화

**코드 구조:**
```typescript
const handleLikeChange = useCallback((postId: string, liked: boolean, newCount: number) => {
  setPosts((prevPosts) =>
    prevPosts.map((post) =>
      post.id === postId
        ? { ...post, is_liked: liked, likes_count: newCount }
        : post
    )
  );
}, []);

// PostCard에 전달
<PostCard 
  post={post} 
  currentUserId={currentUserId}
  onLikeChange={handleLikeChange}
/>
```

---

## 5. 작업 순서

### 단계 1: API Route 생성 (우선순위: 높음)
1. `app/api/likes/route.ts` 생성
2. POST 핸들러 구현
3. DELETE 핸들러 구현
4. 인증 및 에러 처리
5. 테스트 (Postman 또는 브라우저 개발자 도구)

### 단계 2: LikeButton 컴포넌트 생성 (우선순위: 높음)
1. `components/post/LikeButton.tsx` 생성
2. 기본 UI 구현 (하트 아이콘)
3. 클릭 핸들러 구현
4. 클릭 애니메이션 구현
5. API 호출 통합
6. Optimistic Update 구현

### 단계 3: PostCard 통합 (우선순위: 중간)
1. LikeButton을 PostCard에 추가
2. 좋아요 수 표시 업데이트
3. 상태 동기화

### 단계 4: 더블탭 기능 구현 (우선순위: 낮음)
1. 더블탭 감지 로직 구현
2. 큰 하트 애니메이션 구현
3. PostCard에 통합

### 단계 5: PostFeed 상태 업데이트 (우선순위: 중간)
1. 좋아요 변경 핸들러 구현
2. 상태 동기화

### 단계 6: 스타일링 및 다듬기 (우선순위: 낮음)
1. Instagram 디자인에 맞게 스타일 조정
2. 애니메이션 타이밍 조정
3. 반응형 확인
4. 접근성 개선 (ARIA 레이블 등)

---

## 6. 참고 파일

- [PRD.md](../docs/PRD.md) - 좋아요 기능 정의 (278-283줄, 313-327줄)
- [TODO.md](../docs/TODO.md) - 좋아요 기능 TODO (87-99줄)
- [db.sql](../../supabase/migrations/db.sql) - likes 테이블 스키마 (63-86줄)
- [lib/types.ts](../../lib/types.ts) - TypeScript 타입 정의
- [lib/supabase/server.ts](../../lib/supabase/server.ts) - Supabase 서버 클라이언트
- [app/api/posts/route.ts](../../app/api/posts/route.ts) - API Route 예시
- [components/post/PostCard.tsx](../../components/post/PostCard.tsx) - PostCard 컴포넌트

---

## 7. 주의사항

1. **중복 좋아요 방지**: DB 제약조건 (`UNIQUE(post_id, user_id)`) 활용
2. **Optimistic Update**: 즉시 UI 업데이트 후 API 호출, 실패 시 롤백
3. **에러 처리**: 네트워크 에러, 인증 에러 등 모든 경우 처리
4. **성능**: 불필요한 리렌더링 방지 (useCallback, useMemo 활용)
5. **접근성**: 키보드 네비게이션, 스크린 리더 지원
6. **모바일 최적화**: 더블탭 기능은 모바일에서만 활성화 고려

---

## 8. 테스트 체크리스트

- [ ] API Route 테스트
  - [ ] 인증되지 않은 사용자 → 401
  - [ ] 잘못된 post_id → 400
  - [ ] 존재하지 않는 게시물 → 404
  - [ ] 중복 좋아요 → 409
  - [ ] 정상 좋아요 추가 → 200
  - [ ] 정상 좋아요 제거 → 200

- [ ] LikeButton 컴포넌트 테스트
  - [ ] 클릭 시 하트 상태 변경
  - [ ] 클릭 애니메이션 동작
  - [ ] API 호출 성공 시 상태 유지
  - [ ] API 호출 실패 시 롤백
  - [ ] 로딩 상태 표시

- [ ] PostCard 통합 테스트
  - [ ] LikeButton 표시
  - [ ] 좋아요 수 업데이트
  - [ ] 더블탭 좋아요 (모바일)

- [ ] PostFeed 상태 동기화 테스트
  - [ ] 좋아요 변경 시 피드 상태 업데이트
  - [ ] 여러 PostCard에서 동일 게시물 동기화

- [ ] 반응형 테스트
  - [ ] 모바일에서 더블탭 동작
  - [ ] 데스크톱에서 클릭 동작
  - [ ] 다양한 화면 크기에서 UI 확인

---

## 9. 예상 소요 시간

- API Route 생성: 1-2시간
- LikeButton 컴포넌트: 2-3시간
- PostCard 통합: 1시간
- 더블탭 기능: 1-2시간
- PostFeed 상태 업데이트: 30분
- 테스트 및 다듬기: 1-2시간

**총 예상 시간: 6-10시간**
