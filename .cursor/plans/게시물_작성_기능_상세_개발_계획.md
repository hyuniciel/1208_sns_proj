# 게시물 작성 기능 상세 개발 계획

## 개요

Instagram 스타일의 게시물 작성 기능을 구현합니다. 사용자가 이미지를 업로드하고 캡션을 입력하여 게시물을 생성할 수 있습니다.

**참고 문서:**
- [PRD.md](../docs/PRD.md) - 게시물 작성 기능 정의 (267-276줄, 448-460줄)
- [db.sql](../../supabase/migrations/db.sql) - posts 테이블 스키마 (36-43줄)
- [TODO.md](../docs/TODO.md) - 게시물 작성 기능 TODO (101-116줄)

**현재 상태:**
- ✅ `posts` 테이블 생성 완료 (DB 스키마)
- ✅ `posts` Storage 버킷 생성 완료 (공개 읽기, 5MB 제한)
- ✅ `app/api/posts/route.ts`에 GET 핸들러 존재
- ❌ `CreatePostModal.tsx` 컴포넌트 미구현
- ❌ `app/api/posts/route.ts`에 POST 핸들러 미구현
- ❌ Sidebar "만들기" 버튼 연결 미구현

---

## 1. CreatePostModal 컴포넌트 생성

### 1.1 `components/post/CreatePostModal.tsx` 생성

**파일 경로:** `components/post/CreatePostModal.tsx`

**기능:**
- Dialog 컴포넌트 사용 (shadcn/ui)
- 이미지 선택 및 미리보기
- 캡션 입력 필드 (최대 2,200자)
- 파일 검증 (크기, 타입)
- 업로드 진행 상태 표시
- 성공/실패 피드백

**Props 타입:**
```typescript
interface CreatePostModalProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSuccess?: () => void; // 업로드 성공 시 콜백
}
```

**상태 관리:**
- `selectedFile`: 선택된 이미지 파일
- `previewUrl`: 미리보기 이미지 URL
- `caption`: 캡션 텍스트
- `isUploading`: 업로드 진행 중 여부
- `error`: 에러 메시지
- `charCount`: 캡션 글자 수

**구현 세부사항:**

1. **Dialog 구조**
   - Header: "새 게시물 만들기" 제목
   - Content: 이미지 미리보기 영역 + 입력 필드
   - Footer: "공유하기" 버튼

2. **이미지 선택**
   - 파일 입력 필드 (hidden)
   - "사진 선택" 버튼 클릭 시 파일 선택 다이얼로그 열기
   - 선택된 파일 미리보기 표시
   - 이미지 교체 가능 (다시 선택 버튼)

3. **이미지 미리보기**
   - 선택된 이미지 표시 (1:1 비율 유지)
   - 이미지가 없을 때: "사진 선택" 플레이스홀더
   - 이미지가 있을 때: 선택된 이미지 표시

4. **캡션 입력**
   - Textarea 컴포넌트 사용
   - Placeholder: "문구 입력..."
   - 최대 2,200자 제한
   - 글자 수 표시 (예: "1,234 / 2,200")
   - 실시간 글자 수 업데이트

5. **파일 검증**
   - 파일 크기: 최대 5MB
   - 파일 타입: JPEG, PNG, WebP, GIF만 허용
   - 검증 실패 시 에러 메시지 표시

6. **업로드 진행 상태**
   - 업로드 중: 버튼 비활성화, 로딩 스피너 표시
   - 성공: 모달 닫기, 성공 메시지 (선택적)
   - 실패: 에러 메시지 표시

**코드 구조:**
```typescript
'use client';

import { useState, useRef, useCallback } from 'react';
import { X, Image as ImageIcon, Loader2 } from 'lucide-react';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';

interface CreatePostModalProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSuccess?: () => void;
}

const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB
const MAX_CAPTION_LENGTH = 2200;
const ALLOWED_MIME_TYPES = [
  'image/jpeg',
  'image/png',
  'image/webp',
  'image/gif',
];

export default function CreatePostModal({
  open,
  onOpenChange,
  onSuccess,
}: CreatePostModalProps) {
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);
  const [caption, setCaption] = useState('');
  const [isUploading, setIsUploading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const charCount = caption.length;

  // 파일 선택 핸들러
  const handleFileSelect = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    // 파일 검증
    if (file.size > MAX_FILE_SIZE) {
      setError(`파일 크기는 ${MAX_FILE_SIZE / 1024 / 1024}MB를 초과할 수 없습니다.`);
      return;
    }

    if (!ALLOWED_MIME_TYPES.includes(file.type)) {
      setError('JPEG, PNG, WebP, GIF 파일만 업로드할 수 있습니다.');
      return;
    }

    setError(null);
    setSelectedFile(file);

    // 미리보기 URL 생성
    const url = URL.createObjectURL(file);
    setPreviewUrl(url);
  }, []);

  // 파일 선택 버튼 클릭
  const handleSelectClick = () => {
    fileInputRef.current?.click();
  };

  // 이미지 제거
  const handleRemoveImage = () => {
    if (previewUrl) {
      URL.revokeObjectURL(previewUrl);
    }
    setSelectedFile(null);
    setPreviewUrl(null);
    setError(null);
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  // 업로드 핸들러
  const handleUpload = useCallback(async () => {
    if (!selectedFile) {
      setError('이미지를 선택해주세요.');
      return;
    }

    if (charCount > MAX_CAPTION_LENGTH) {
      setError(`캡션은 최대 ${MAX_CAPTION_LENGTH}자까지 입력할 수 있습니다.`);
      return;
    }

    setIsUploading(true);
    setError(null);

    try {
      const formData = new FormData();
      formData.append('image', selectedFile);
      formData.append('caption', caption.trim() || '');

      const response = await fetch('/api/posts', {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || '게시물 업로드에 실패했습니다.');
      }

      // 성공 시 처리
      const data = await response.json();
      console.log('게시물 업로드 성공:', data);

      // 상태 초기화
      handleRemoveImage();
      setCaption('');
      
      // 모달 닫기
      onOpenChange(false);
      
      // 성공 콜백 호출
      if (onSuccess) {
        onSuccess();
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : '알 수 없는 오류가 발생했습니다.');
      console.error('업로드 에러:', err);
    } finally {
      setIsUploading(false);
    }
  }, [selectedFile, caption, charCount, onOpenChange, onSuccess]);

  // 모달 닫기 시 정리
  const handleClose = useCallback(() => {
    if (previewUrl) {
      URL.revokeObjectURL(previewUrl);
    }
    setSelectedFile(null);
    setPreviewUrl(null);
    setCaption('');
    setError(null);
    setIsUploading(false);
    onOpenChange(false);
  }, [previewUrl, onOpenChange]);

  return (
    <Dialog open={open} onOpenChange={handleClose}>
      <DialogContent className="sm:max-w-[600px] p-0">
        <DialogHeader className="px-6 py-4 border-b">
          <DialogTitle>새 게시물 만들기</DialogTitle>
        </DialogHeader>

        <div className="flex flex-col md:flex-row">
          {/* 이미지 영역 */}
          <div className="w-full md:w-1/2 aspect-square bg-gray-100 flex items-center justify-center relative">
            {previewUrl ? (
              <>
                <img
                  src={previewUrl}
                  alt="미리보기"
                  className="w-full h-full object-cover"
                />
                <button
                  onClick={handleRemoveImage}
                  className="absolute top-2 right-2 p-2 bg-black/50 rounded-full text-white hover:bg-black/70"
                  disabled={isUploading}
                >
                  <X className="w-4 h-4" />
                </button>
              </>
            ) : (
              <div className="text-center p-8">
                <ImageIcon className="w-16 h-16 text-gray-400 mx-auto mb-4" />
                <p className="text-text-secondary mb-4">사진을 선택해주세요</p>
                <Button onClick={handleSelectClick} disabled={isUploading}>
                  사진 선택
                </Button>
              </div>
            )}
            <input
              ref={fileInputRef}
              type="file"
              accept="image/jpeg,image/png,image/webp,image/gif"
              onChange={handleFileSelect}
              className="hidden"
            />
          </div>

          {/* 입력 영역 */}
          <div className="w-full md:w-1/2 p-6 space-y-4">
            {previewUrl && (
              <>
                <div>
                  <Label htmlFor="caption">문구 입력</Label>
                  <Textarea
                    id="caption"
                    placeholder="문구 입력..."
                    value={caption}
                    onChange={(e) => setCaption(e.target.value)}
                    maxLength={MAX_CAPTION_LENGTH}
                    className="mt-2 min-h-[120px] resize-none"
                    disabled={isUploading}
                  />
                  <div className="flex justify-end mt-1">
                    <span
                      className={`text-xs ${
                        charCount > MAX_CAPTION_LENGTH
                          ? 'text-red-500'
                          : 'text-text-secondary'
                      }`}
                    >
                      {charCount.toLocaleString()} / {MAX_CAPTION_LENGTH.toLocaleString()}
                    </span>
                  </div>
                </div>

                {error && (
                  <div className="text-sm text-red-500 bg-red-50 p-3 rounded">
                    {error}
                  </div>
                )}

                <Button
                  onClick={handleUpload}
                  disabled={isUploading || !selectedFile}
                  className="w-full"
                >
                  {isUploading ? (
                    <>
                      <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                      업로드 중...
                    </>
                  ) : (
                    '공유하기'
                  )}
                </Button>
              </>
            )}
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}
```

**스타일링:**
- 모달 크기: 최대 600px 너비
- 이미지 영역: 1:1 비율 (정사각형)
- 반응형: 모바일에서는 세로 배치
- 에러 메시지: 빨간색 배경, 명확한 메시지

---

## 2. API Route에 POST 핸들러 추가

### 2.1 `app/api/posts/route.ts`에 POST 핸들러 추가

**파일 경로:** `app/api/posts/route.ts`

**기능:**
- POST: 게시물 생성
- 이미지 파일 검증 (최대 5MB)
- Supabase Storage 업로드
- posts 테이블에 데이터 저장
- 인증 검증 (Clerk)

**구현 세부사항:**

1. **인증 확인**
   - Clerk `auth()`로 현재 사용자 확인
   - 인증되지 않은 경우 401 반환

2. **FormData 파싱**
   - `image`: 이미지 파일 (File 객체)
   - `caption`: 캡션 텍스트 (선택적)

3. **파일 검증**
   - 파일 존재 여부 확인
   - 파일 크기: 최대 5MB
   - MIME 타입: JPEG, PNG, WebP, GIF만 허용

4. **사용자 ID 조회**
   - Clerk `userId`로 Supabase `users` 테이블에서 사용자 UUID 조회
   - 사용자가 존재하지 않으면 404 반환

5. **Supabase Storage 업로드**
   - 파일명 생성: `{timestamp}-{random}.{ext}`
   - 경로: `{clerk_user_id}/{filename}`
   - 버킷: `posts` (공개 버킷)
   - 업로드 옵션:
     - `cacheControl: "3600"` (1시간 캐시)
     - `upsert: false` (중복 방지)

6. **Public URL 가져오기**
   - Storage에서 업로드된 파일의 공개 URL 가져오기
   - 형식: `https://{project}.supabase.co/storage/v1/object/public/posts/{path}`

7. **캡션 검증**
   - 최대 2,200자 제한
   - 빈 문자열은 `null`로 저장
   - 앞뒤 공백 제거

8. **posts 테이블에 저장**
   - `user_id`: 사용자 UUID
   - `image_url`: Storage 공개 URL
   - `caption`: 캡션 (null 가능)
   - `created_at`, `updated_at`: 자동 설정

9. **응답 반환**
   ```typescript
   {
     success: true,
     post: {
       id: string,
       user_id: string,
       image_url: string,
       caption: string | null,
       created_at: string,
       updated_at: string
     }
   }
   ```

**코드 구조:**
```typescript
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import { createClerkSupabaseClient } from "@/lib/supabase/server";
import type { Post } from "@/lib/types";

const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB
const ALLOWED_MIME_TYPES = [
  'image/jpeg',
  'image/png',
  'image/webp',
  'image/gif',
];
const MAX_CAPTION_LENGTH = 2200;

/**
 * POST: 게시물 생성
 *
 * 요청 본문 (FormData):
 * - image: File (이미지 파일)
 * - caption: string (선택적, 최대 2,200자)
 *
 * 응답:
 * {
 *   success: true,
 *   post: Post
 * }
 */
export async function POST(request: NextRequest) {
  try {
    console.group("POST /api/posts");

    // 1. 인증 확인
    const { userId: clerkUserId } = await auth();
    if (!clerkUserId) {
      console.log("❌ 인증 실패");
      return NextResponse.json(
        { error: "Unauthorized" },
        { status: 401 }
      );
    }
    console.log("✅ 인증 확인:", clerkUserId);

    // 2. FormData 파싱
    const formData = await request.formData();
    const image = formData.get('image') as File;
    const caption = formData.get('caption') as string | null;

    // 3. 파일 검증
    if (!image) {
      console.log("❌ 이미지 파일 없음");
      return NextResponse.json(
        { error: "Image is required" },
        { status: 400 }
      );
    }

    if (image.size > MAX_FILE_SIZE) {
      console.log("❌ 파일 크기 초과:", image.size);
      return NextResponse.json(
        { error: `File size exceeds ${MAX_FILE_SIZE / 1024 / 1024}MB limit` },
        { status: 400 }
      );
    }

    if (!ALLOWED_MIME_TYPES.includes(image.type)) {
      console.log("❌ 잘못된 파일 타입:", image.type);
      return NextResponse.json(
        { error: "Invalid file type. Only JPEG, PNG, WebP, and GIF are allowed" },
        { status: 400 }
      );
    }

    // 4. 캡션 검증
    const captionText = caption?.trim() || null;
    if (captionText && captionText.length > MAX_CAPTION_LENGTH) {
      console.log("❌ 캡션 길이 초과:", captionText.length);
      return NextResponse.json(
        { error: `Caption exceeds ${MAX_CAPTION_LENGTH} characters` },
        { status: 400 }
      );
    }

    console.log("📋 요청 데이터:", {
      fileName: image.name,
      fileSize: image.size,
      fileType: image.type,
      captionLength: captionText?.length || 0,
    });

    // 5. Supabase 클라이언트 생성
    const supabase = createClerkSupabaseClient();

    // 6. 현재 사용자 UUID 조회
    const { data: currentUser, error: userError } = await supabase
      .from("users")
      .select("id")
      .eq("clerk_id", clerkUserId)
      .single();

    if (userError || !currentUser) {
      console.error("❌ 사용자 조회 실패:", userError);
      return NextResponse.json(
        { error: "User not found" },
        { status: 404 }
      );
    }
    console.log("✅ 현재 사용자 UUID:", currentUser.id);

    // 7. Supabase Storage 업로드
    const fileExt = image.name.split('.').pop() || 'jpg';
    const fileName = `${Date.now()}-${Math.random().toString(36).substring(7)}.${fileExt}`;
    const filePath = `${clerkUserId}/${fileName}`;

    console.log("📤 파일 업로드 시작:", filePath);

    const { data: uploadData, error: uploadError } = await supabase.storage
      .from('posts')
      .upload(filePath, image, {
        cacheControl: '3600',
        upsert: false,
      });

    if (uploadError) {
      console.error("❌ Storage 업로드 실패:", uploadError);
      return NextResponse.json(
        { error: "Failed to upload image", details: uploadError.message },
        { status: 500 }
      );
    }

    console.log("✅ 파일 업로드 완료:", uploadData.path);

    // 8. Public URL 가져오기
    const { data: urlData } = supabase.storage
      .from('posts')
      .getPublicUrl(filePath);

    const imageUrl = urlData.publicUrl;
    console.log("✅ Public URL:", imageUrl);

    // 9. posts 테이블에 저장
    const { data: post, error: postError } = await supabase
      .from("posts")
      .insert({
        user_id: currentUser.id,
        image_url: imageUrl,
        caption: captionText,
      })
      .select()
      .single();

    if (postError) {
      console.error("❌ 게시물 저장 실패:", postError);
      
      // 업로드된 파일 삭제 시도 (롤백)
      await supabase.storage
        .from('posts')
        .remove([filePath])
        .catch(() => {}); // 삭제 실패는 무시

      return NextResponse.json(
        { error: "Failed to create post", details: postError.message },
        { status: 500 }
      );
    }

    console.log("✅ 게시물 생성 완료:", post.id);
    console.groupEnd();

    return NextResponse.json({
      success: true,
      post,
    });
  } catch (error) {
    console.error("❌ POST /api/posts 에러:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
```

**에러 처리:**
- 파일 검증 실패: 400 Bad Request
- 인증 실패: 401 Unauthorized
- 사용자 없음: 404 Not Found
- Storage 업로드 실패: 500 Internal Server Error (롤백 시도)
- DB 저장 실패: 500 Internal Server Error (업로드된 파일 삭제 시도)

---

## 3. Sidebar "만들기" 버튼 연결

### 3.1 `components/layout/Sidebar.tsx` 업데이트

**변경 사항:**

1. **CreatePostModal import 및 상태 관리**
   - `useState`로 모달 열림/닫힘 상태 관리
   - `CreatePostModal` 컴포넌트 import

2. **"만들기" 버튼 onClick 핸들러**
   - 기존 `console.log` 제거
   - 모달 열기 함수로 교체

3. **업로드 성공 콜백**
   - 게시물 업로드 성공 시 피드 새로고침 (선택적)
   - 또는 부모 컴포넌트에 알림

**코드 변경 예시:**
```typescript
// Sidebar.tsx에 추가
import { useState } from 'react';
import CreatePostModal from '@/components/post/CreatePostModal';

export default function Sidebar() {
  const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);
  
  // ... 기존 코드 ...

  const navItems: NavItem[] = [
    // ... 기존 항목들 ...
    {
      href: "#",
      icon: PlusSquare,
      label: "만들기",
      onClick: () => {
        setIsCreateModalOpen(true);
      },
    },
    // ... 기존 항목들 ...
  ];

  return (
    <>
      <aside className="...">
        {/* 기존 사이드바 내용 */}
      </aside>
      
      <CreatePostModal
        open={isCreateModalOpen}
        onOpenChange={setIsCreateModalOpen}
        onSuccess={() => {
          // 업로드 성공 시 처리 (선택적)
          // 예: 페이지 새로고침 또는 피드 업데이트
          window.location.reload();
        }}
      />
    </>
  );
}
```

### 3.2 `components/layout/BottomNav.tsx` 업데이트

**변경 사항:**
- Sidebar와 동일하게 CreatePostModal 연결
- 모바일에서도 동일한 기능 제공

---

## 4. PostFeed 업데이트 (선택적)

### 4.1 게시물 업로드 후 피드 새로고침

**옵션 1: 페이지 새로고침**
- 간단하지만 전체 페이지 리로드

**옵션 2: 피드 상태 업데이트**
- 새 게시물을 피드 맨 위에 추가
- 더 나은 UX

**코드 예시 (옵션 2):**
```typescript
// PostFeed.tsx에 추가
const handlePostCreated = useCallback(async () => {
  // 피드 맨 위에 새 게시물 추가
  await loadPosts(0, false);
}, [loadPosts]);

// CreatePostModal에 전달
<CreatePostModal
  open={isCreateModalOpen}
  onOpenChange={setIsCreateModalOpen}
  onSuccess={handlePostCreated}
/>
```

---

## 5. 작업 순서

### 단계 1: CreatePostModal 컴포넌트 생성 (우선순위: 높음)
1. `components/post/CreatePostModal.tsx` 생성
2. Dialog 구조 구현
3. 이미지 선택 및 미리보기 구현
4. 캡션 입력 필드 구현
5. 파일 검증 로직 구현
6. UI 스타일링

### 단계 2: API Route POST 핸들러 구현 (우선순위: 높음)
1. `app/api/posts/route.ts`에 POST 핸들러 추가
2. FormData 파싱 구현
3. 파일 검증 구현
4. Supabase Storage 업로드 구현
5. posts 테이블 저장 구현
6. 에러 처리 및 롤백 구현

### 단계 3: Sidebar 연결 (우선순위: 중간)
1. Sidebar에 CreatePostModal 통합
2. "만들기" 버튼 onClick 핸들러 수정
3. BottomNav에도 동일하게 적용

### 단계 4: 피드 업데이트 (우선순위: 낮음)
1. 업로드 성공 시 피드 새로고침 로직 구현
2. 또는 새 게시물을 피드 맨 위에 추가

### 단계 5: 테스트 및 다듬기 (우선순위: 중간)
1. 다양한 이미지 크기 테스트
2. 에러 케이스 테스트
3. UI/UX 개선
4. 접근성 개선

---

## 6. 참고 파일

- [PRD.md](../docs/PRD.md) - 게시물 작성 기능 정의 (267-276줄, 448-460줄)
- [TODO.md](../docs/TODO.md) - 게시물 작성 기능 TODO (101-116줄)
- [db.sql](../../supabase/migrations/db.sql) - posts 테이블 스키마 (36-43줄)
- [lib/types.ts](../../lib/types.ts) - TypeScript 타입 정의
- [lib/supabase/server.ts](../../lib/supabase/server.ts) - Supabase 서버 클라이언트
- [components/ui/dialog.tsx](../../components/ui/dialog.tsx) - Dialog 컴포넌트
- [components/ui/textarea.tsx](../../components/ui/textarea.tsx) - Textarea 컴포넌트
- [app/storage-test/page.tsx](../../app/storage-test/page.tsx) - Storage 업로드 예시

---

## 7. 주의사항

1. **파일 크기 제한**: 5MB (PRD 기준)
2. **파일 타입 제한**: 이미지 파일만 허용
3. **캡션 길이 제한**: 최대 2,200자
4. **에러 처리**: 업로드 실패 시 Storage 파일 삭제 시도
5. **메모리 관리**: 미리보기 URL 해제 (URL.revokeObjectURL)
6. **접근성**: 키보드 네비게이션, 스크린 리더 지원
7. **Storage 버킷**: `posts` 버킷 사용 (공개 읽기)

---

## 8. 테스트 체크리스트

- [ ] CreatePostModal 컴포넌트 테스트
  - [ ] 모달 열기/닫기
  - [ ] 이미지 선택 및 미리보기
  - [ ] 이미지 제거
  - [ ] 캡션 입력 (글자 수 제한)
  - [ ] 파일 검증 (크기, 타입)
  - [ ] 업로드 진행 상태 표시

- [ ] API Route POST 테스트
  - [ ] 인증되지 않은 사용자 → 401
  - [ ] 이미지 파일 없음 → 400
  - [ ] 파일 크기 초과 → 400
  - [ ] 잘못된 파일 타입 → 400
  - [ ] 캡션 길이 초과 → 400
  - [ ] 정상 업로드 → 200
  - [ ] Storage 업로드 실패 시 롤백
  - [ ] DB 저장 실패 시 파일 삭제

- [ ] Sidebar 연결 테스트
  - [ ] "만들기" 버튼 클릭 시 모달 열림
  - [ ] 업로드 성공 시 피드 업데이트

- [ ] 통합 테스트
  - [ ] 게시물 업로드 후 피드에 표시
  - [ ] 업로드된 이미지 정상 표시
  - [ ] 캡션 정상 표시

- [ ] 반응형 테스트
  - [ ] 모바일에서 모달 동작
  - [ ] 데스크톱에서 모달 동작
  - [ ] 다양한 화면 크기에서 UI 확인

---

## 9. 예상 소요 시간

- CreatePostModal 컴포넌트: 3-4시간
- API Route POST 핸들러: 2-3시간
- Sidebar 연결: 30분
- 피드 업데이트: 1시간
- 테스트 및 다듬기: 1-2시간

**총 예상 시간: 7-10시간**

---

## 10. 추가 개선 사항 (선택적)

1. **이미지 편집 기능**
   - 크롭, 필터 등 (나중에 구현)

2. **드래그 앤 드롭**
   - 파일을 모달에 드래그하여 업로드

3. **다중 이미지 업로드**
   - 여러 이미지 선택 (나중에 구현)

4. **업로드 진행률 표시**
   - Progress bar로 업로드 진행률 표시

5. **이미지 압축**
   - 클라이언트 사이드에서 이미지 압축 (성능 개선)

