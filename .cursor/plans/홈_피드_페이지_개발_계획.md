# 홈 피드 페이지 개발 계획

## 개요

Instagram 스타일의 홈 피드 페이지를 구현합니다. 게시물 목록을 시간 역순으로 표시하고, 무한 스크롤을 통해 페이지네이션을 처리합니다.

## 1. API Route 생성: 게시물 목록 조회

### 1.1 `app/api/posts/route.ts` 생성

**기능:**
- GET: 게시물 목록 조회 (시간 역순 정렬)
- 페이지네이션 지원 (limit, offset)
- 선택적 userId 파라미터 (프로필 페이지용)
- 현재 사용자의 좋아요 상태 포함

**구현 세부사항:**

#### GET 핸들러

1. **인증 확인**
   - Clerk `auth()`로 현재 사용자 확인
   - 인증되지 않은 경우 401 반환

2. **쿼리 파라미터 처리**
   - `limit`: 페이지당 게시물 수 (기본값: 10, 최대: 50)
   - `offset`: 건너뛸 게시물 수 (기본값: 0)
   - `userId`: 특정 사용자의 게시물만 조회 (선택적)

3. **사용자 ID 조회**
   - Clerk `userId`로 Supabase `users` 테이블에서 사용자 UUID 조회
   - 사용자가 존재하지 않으면 404 반환

4. **데이터베이스 쿼리**
   - `post_stats` 뷰 사용하여 좋아요/댓글 수 포함
   - `users` 테이블과 JOIN하여 사용자 정보 포함
   - `created_at DESC` 정렬 (최신순)
   - `userId` 파라미터가 있으면 `user_id`로 필터링
   - `LIMIT`과 `OFFSET`으로 페이지네이션

5. **좋아요 상태 확인**
   - 현재 사용자가 각 게시물에 좋아요를 눌렀는지 확인
   - `likes` 테이블에서 현재 사용자 ID로 조회
   - `is_liked` 필드로 응답에 포함

6. **응답 형식**
   ```typescript
   {
     data: PostWithUser[],
     has_more: boolean,
     next_offset?: number
   }
   ```

**코드 구조:**
```typescript
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import { createClerkSupabaseClient } from "@/lib/supabase/server";
import type { PostWithUser } from "@/lib/types";

export async function GET(request: NextRequest) {
  try {
    // 1. 인증 확인
    const { userId: clerkUserId } = await auth();
    if (!clerkUserId) {
      return NextResponse.json(
        { error: "Unauthorized" },
        { status: 401 }
      );
    }

    // 2. 쿼리 파라미터 처리
    const { searchParams } = new URL(request.url);
    const limit = Math.min(
      parseInt(searchParams.get("limit") || "10"),
      50
    );
    const offset = parseInt(searchParams.get("offset") || "0");
    const userId = searchParams.get("userId");

    // 3. Supabase 클라이언트 생성
    const supabase = createClerkSupabaseClient();

    // 4. 현재 사용자 UUID 조회
    const { data: currentUser, error: userError } = await supabase
      .from("users")
      .select("id")
      .eq("clerk_id", clerkUserId)
      .single();

    if (userError || !currentUser) {
      return NextResponse.json(
        { error: "User not found" },
        { status: 404 }
      );
    }

    // 5. 게시물 목록 조회 (post_stats 뷰 사용)
    let query = supabase
      .from("post_stats")
      .select(`
        post_id,
        user_id,
        image_url,
        caption,
        created_at,
        likes_count,
        comments_count,
        users!post_stats_user_id_fkey (
          id,
          clerk_id,
          name,
          created_at
        )
      `)
      .order("created_at", { ascending: false })
      .range(offset, offset + limit - 1);

    // userId 파라미터가 있으면 필터링
    if (userId) {
      query = query.eq("user_id", userId);
    }

    const { data: posts, error: postsError } = await query;

    if (postsError) {
      console.error("Posts query error:", postsError);
      return NextResponse.json(
        { error: "Failed to fetch posts" },
        { status: 500 }
      );
    }

    // 6. 좋아요 상태 확인
    const postIds = posts?.map((p) => p.post_id) || [];
    const { data: likes } = await supabase
      .from("likes")
      .select("post_id")
      .eq("user_id", currentUser.id)
      .in("post_id", postIds);

    const likedPostIds = new Set(likes?.map((l) => l.post_id) || []);

    // 7. 응답 데이터 형식 변환
    const formattedPosts: PostWithUser[] = (posts || []).map((post) => ({
      id: post.post_id,
      user_id: post.user_id,
      image_url: post.image_url,
      caption: post.caption,
      created_at: post.created_at,
      updated_at: post.created_at, // post_stats에는 updated_at이 없으므로 created_at 사용
      likes_count: post.likes_count || 0,
      comments_count: post.comments_count || 0,
      user: {
        id: post.users.id,
        clerk_id: post.users.clerk_id,
        name: post.users.name,
        created_at: post.users.created_at,
      },
      is_liked: likedPostIds.has(post.post_id),
    }));

    // 8. 다음 페이지 존재 여부 확인
    const hasMore = formattedPosts.length === limit;

    return NextResponse.json({
      data: formattedPosts,
      has_more: hasMore,
      next_offset: hasMore ? offset + limit : undefined,
    });
  } catch (error) {
    console.error("GET /api/posts error:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
```

**에러 처리:**
- 인증 실패: 401 Unauthorized
- 사용자 없음: 404 Not Found
- 데이터베이스 에러: 500 Internal Server Error
- 잘못된 파라미터: 400 Bad Request

## 2. PostCardSkeleton 컴포넌트

### 2.1 `components/post/PostCardSkeleton.tsx` 생성

**기능:**
- 로딩 중 PostCard의 스켈레톤 UI
- Shimmer 애니메이션 효과
- PostCard와 동일한 레이아웃

**구현 세부사항:**

1. **레이아웃 구조**
   - 헤더 영역 (프로필 이미지 + 텍스트)
   - 이미지 영역 (1:1 정사각형)
   - 액션 버튼 영역
   - 컨텐츠 영역 (좋아요 수 + 캡션)

2. **Shimmer 효과**
   - CSS 애니메이션 사용
   - 그라데이션 이동 효과
   - `animate-pulse`와 커스텀 애니메이션 조합

**코드 구조:**
```typescript
export default function PostCardSkeleton() {
  return (
    <div className="bg-card-background border border-border rounded-lg mb-4">
      {/* 헤더 */}
      <div className="flex items-center gap-3 px-4 py-3">
        <div className="w-8 h-8 rounded-full bg-gray-200 animate-pulse" />
        <div className="flex-1 space-y-2">
          <div className="h-4 w-24 bg-gray-200 rounded animate-pulse" />
          <div className="h-3 w-16 bg-gray-200 rounded animate-pulse" />
        </div>
      </div>

      {/* 이미지 */}
      <div className="w-full aspect-square bg-gray-200 animate-pulse" />

      {/* 액션 버튼 */}
      <div className="flex items-center justify-between px-4 py-3">
        <div className="flex items-center gap-4">
          <div className="w-6 h-6 bg-gray-200 rounded animate-pulse" />
          <div className="w-6 h-6 bg-gray-200 rounded animate-pulse" />
          <div className="w-6 h-6 bg-gray-200 rounded animate-pulse" />
        </div>
        <div className="w-6 h-6 bg-gray-200 rounded animate-pulse" />
      </div>

      {/* 컨텐츠 */}
      <div className="px-4 pb-4 space-y-2">
        <div className="h-4 w-32 bg-gray-200 rounded animate-pulse" />
        <div className="space-y-1">
          <div className="h-4 w-full bg-gray-200 rounded animate-pulse" />
          <div className="h-4 w-3/4 bg-gray-200 rounded animate-pulse" />
        </div>
      </div>
    </div>
  );
}
```

**스타일링:**
- `animate-pulse`: Tailwind 기본 펄스 애니메이션
- 회색 배경 (`bg-gray-200`)
- PostCard와 동일한 패딩 및 간격

## 3. PostCard 컴포넌트

### 3.1 `components/post/PostCard.tsx` 생성

**기능:**
- 게시물 카드 UI 렌더링
- 헤더, 이미지, 액션 버튼, 컨텐츠 표시
- 상대 시간 표시
- 캡션 "더 보기" 기능

**Props 타입:**
```typescript
interface PostCardProps {
  post: PostWithUser;
  currentUserId?: string; // 현재 사용자 ID (삭제 버튼 표시용)
}
```

**구현 세부사항:**

#### 1. 헤더 영역 (60px 높이)

- 프로필 이미지: 32px 원형 (기본 아바타 또는 Clerk 프로필 이미지)
- 사용자명: Bold, 클릭 시 프로필 페이지로 이동
- 상대 시간: 작은 폰트, 회색
- ⋯ 메뉴: 우측 정렬 (본인 게시물만 삭제 옵션, 나중에 구현)

#### 2. 이미지 영역

- 1:1 정사각형 비율 (`aspect-square`)
- Next.js Image 컴포넌트 사용
- Lazy loading
- 더블탭 좋아요 (나중에 구현)

#### 3. 액션 버튼 영역 (48px 높이)

- 좋아요 버튼: 빈 하트/빨간 하트 (나중에 구현)
- 댓글 버튼: 클릭 시 댓글 입력창 포커스 (나중에 구현)
- 공유 버튼: UI만 (기능 제외)
- 북마크 버튼: UI만 (기능 제외)

#### 4. 컨텐츠 영역

- 좋아요 수: Bold, "좋아요 1,234개" 형식
- 캡션: 사용자명 Bold + 내용
- 2줄 초과 시 "... 더 보기" 버튼
- 댓글 미리보기: 최신 2개만 (나중에 구현)
- "댓글 모두 보기" 링크 (나중에 구현)

**코드 구조:**
```typescript
'use client';

import { useState } from 'react';
import Image from 'next/image';
import Link from 'next/link';
import { Heart, MessageCircle, Send, Bookmark, MoreHorizontal } from 'lucide-react';
import { Button } from '@/components/ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { formatRelativeTime } from '@/lib/utils/time';
import type { PostWithUser } from '@/lib/types';

interface PostCardProps {
  post: PostWithUser;
  currentUserId?: string;
}

export default function PostCard({ post, currentUserId }: PostCardProps) {
  const [showFullCaption, setShowFullCaption] = useState(false);
  const [captionLines, setCaptionLines] = useState(0);

  // 캡션 줄 수 계산 (ref 사용, 나중에 구현)
  const shouldTruncate = captionLines > 2;
  const displayCaption = shouldTruncate && !showFullCaption
    ? post.caption?.substring(0, 100) + '...'
    : post.caption;

  return (
    <article className="bg-card-background border border-border rounded-lg mb-4">
      {/* 헤더 */}
      <header className="flex items-center justify-between px-4 py-3 h-[60px]">
        <div className="flex items-center gap-3">
          <Link href={`/profile/${post.user.id}`}>
            <div className="w-8 h-8 rounded-full bg-gray-200 overflow-hidden">
              {/* 프로필 이미지 (Clerk 또는 기본 아바타) */}
            </div>
          </Link>
          <div>
            <Link
              href={`/profile/${post.user.id}`}
              className="font-bold text-text-primary hover:opacity-70"
            >
              {post.user.name}
            </Link>
            <p className="text-text-secondary text-xs">
              {formatRelativeTime(post.created_at)}
            </p>
          </div>
        </div>

        {/* ⋯ 메뉴 (본인 게시물만) */}
        {currentUserId === post.user_id && (
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="ghost" size="sm">
                <MoreHorizontal className="w-5 h-5" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent>
              <DropdownMenuItem className="text-red-500">
                삭제
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        )}
      </header>

      {/* 이미지 */}
      <div className="w-full aspect-square relative bg-gray-100">
        <Image
          src={post.image_url}
          alt={post.caption || '게시물 이미지'}
          fill
          className="object-cover"
          sizes="(max-width: 768px) 100vw, 630px"
          loading="lazy"
        />
      </div>

      {/* 액션 버튼 */}
      <div className="flex items-center justify-between px-4 py-3 h-[48px]">
        <div className="flex items-center gap-4">
          <Button variant="ghost" size="sm" className="p-0">
            <Heart
              className={`w-6 h-6 ${
                post.is_liked
                  ? 'fill-like text-like'
                  : 'text-text-primary'
              }`}
            />
          </Button>
          <Button variant="ghost" size="sm" className="p-0">
            <MessageCircle className="w-6 h-6 text-text-primary" />
          </Button>
          <Button variant="ghost" size="sm" className="p-0">
            <Send className="w-6 h-6 text-text-primary" />
          </Button>
        </div>
        <Button variant="ghost" size="sm" className="p-0">
          <Bookmark className="w-6 h-6 text-text-primary" />
        </Button>
      </div>

      {/* 컨텐츠 */}
      <div className="px-4 pb-4 space-y-2">
        {/* 좋아요 수 */}
        {post.likes_count > 0 && (
          <p className="font-bold text-text-primary">
            좋아요 {post.likes_count.toLocaleString()}개
          </p>
        )}

        {/* 캡션 */}
        {post.caption && (
          <div className="text-text-primary">
            <Link
              href={`/profile/${post.user.id}`}
              className="font-bold hover:opacity-70"
            >
              {post.user.name}
            </Link>
            {' '}
            <span>{displayCaption}</span>
            {shouldTruncate && !showFullCaption && (
              <button
                onClick={() => setShowFullCaption(true)}
                className="text-text-secondary hover:text-text-primary ml-1"
              >
                더 보기
              </button>
            )}
          </div>
        )}

        {/* 댓글 미리보기 (나중에 구현) */}
        {post.comments_count > 0 && (
          <button className="text-text-secondary text-sm hover:text-text-primary">
            댓글 {post.comments_count}개 모두 보기
          </button>
        )}
      </div>
    </article>
  );
}
```

**스타일링:**
- Instagram 디자인에 맞는 색상 및 간격
- Hover 효과
- 반응형 레이아웃

## 4. PostFeed 컴포넌트

### 4.1 `components/post/PostFeed.tsx` 생성

**기능:**
- 게시물 목록 렌더링
- 무한 스크롤 (Intersection Observer)
- 페이지네이션 (10개씩)
- 로딩 상태 관리
- 에러 처리

**Props 타입:**
```typescript
interface PostFeedProps {
  userId?: string; // 특정 사용자의 게시물만 표시 (프로필 페이지용)
}
```

**구현 세부사항:**

1. **상태 관리**
   - `posts`: 게시물 목록
   - `isLoading`: 초기 로딩 상태
   - `isLoadingMore`: 추가 로딩 상태
   - `hasMore`: 더 불러올 데이터가 있는지
   - `error`: 에러 메시지
   - `offset`: 현재 오프셋

2. **초기 데이터 로드**
   - 컴포넌트 마운트 시 `/api/posts` 호출
   - `limit=10`, `offset=0`으로 시작

3. **무한 스크롤**
   - Intersection Observer API 사용
   - 하단 감지 요소 (sentinel) 생성
   - 감지 시 다음 페이지 로드

4. **다음 페이지 로드**
   - `offset` 증가
   - `/api/posts` 호출
   - 기존 게시물에 추가

5. **에러 처리**
   - 네트워크 에러: 재시도 버튼 표시
   - API 에러: 에러 메시지 표시

**코드 구조:**
```typescript
'use client';

import { useState, useEffect, useRef, useCallback } from 'react';
import PostCard from './PostCard';
import PostCardSkeleton from './PostCardSkeleton';
import { useUser } from '@clerk/nextjs';
import type { PostWithUser } from '@/lib/types';

interface PostFeedProps {
  userId?: string;
}

export default function PostFeed({ userId }: PostFeedProps) {
  const { user } = useUser();
  const [posts, setPosts] = useState<PostWithUser[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isLoadingMore, setIsLoadingMore] = useState(false);
  const [hasMore, setHasMore] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [offset, setOffset] = useState(0);
  const sentinelRef = useRef<HTMLDivElement>(null);

  // 게시물 로드 함수
  const loadPosts = useCallback(async (currentOffset: number, append: boolean = false) => {
    try {
      if (append) {
        setIsLoadingMore(true);
      } else {
        setIsLoading(true);
        setError(null);
      }

      const params = new URLSearchParams({
        limit: '10',
        offset: currentOffset.toString(),
      });
      if (userId) {
        params.append('userId', userId);
      }

      const response = await fetch(`/api/posts?${params}`);
      if (!response.ok) {
        throw new Error('게시물을 불러오는데 실패했습니다.');
      }

      const data = await response.json();
      const newPosts = data.data || [];

      if (append) {
        setPosts((prev) => [...prev, ...newPosts]);
      } else {
        setPosts(newPosts);
      }

      setHasMore(data.has_more);
      setOffset(currentOffset + newPosts.length);
    } catch (err) {
      setError(err instanceof Error ? err.message : '알 수 없는 오류가 발생했습니다.');
    } finally {
      setIsLoading(false);
      setIsLoadingMore(false);
    }
  }, [userId]);

  // 초기 로드
  useEffect(() => {
    loadPosts(0, false);
  }, [loadPosts]);

  // 무한 스크롤 설정
  useEffect(() => {
    if (!hasMore || isLoading || isLoadingMore) return;

    const observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting && hasMore && !isLoadingMore) {
          loadPosts(offset, true);
        }
      },
      { threshold: 0.1 }
    );

    const sentinel = sentinelRef.current;
    if (sentinel) {
      observer.observe(sentinel);
    }

    return () => {
      if (sentinel) {
        observer.unobserve(sentinel);
      }
    };
  }, [hasMore, isLoading, isLoadingMore, offset, loadPosts]);

  // 현재 사용자 ID (Clerk에서 가져오기, 나중에 구현)
  const currentUserId = user?.id; // 실제로는 Supabase users 테이블의 UUID 필요

  if (isLoading) {
    return (
      <div className="space-y-4">
        {Array.from({ length: 3 }).map((_, i) => (
          <PostCardSkeleton key={i} />
        ))}
      </div>
    );
  }

  if (error) {
    return (
      <div className="text-center py-8">
        <p className="text-text-secondary mb-4">{error}</p>
        <button
          onClick={() => loadPosts(0, false)}
          className="text-instagram-blue hover:opacity-70"
        >
          다시 시도
        </button>
      </div>
    );
  }

  if (posts.length === 0) {
    return (
      <div className="text-center py-8">
        <p className="text-text-secondary">게시물이 없습니다.</p>
      </div>
    );
  }

  return (
    <div className="space-y-4">
      {posts.map((post) => (
        <PostCard key={post.id} post={post} currentUserId={currentUserId} />
      ))}

      {/* 무한 스크롤 감지 요소 */}
      {hasMore && (
        <div ref={sentinelRef} className="h-4">
          {isLoadingMore && (
            <div className="space-y-4">
              {Array.from({ length: 2 }).map((_, i) => (
                <PostCardSkeleton key={i} />
              ))}
            </div>
          )}
        </div>
      )}
    </div>
  );
}
```

**스타일링:**
- 게시물 간격: `space-y-4`
- 빈 상태 메시지: 중앙 정렬, 회색 텍스트
- 에러 메시지: 재시도 버튼 포함

## 5. 홈 페이지 업데이트

### 5.1 `app/(main)/page.tsx` 업데이트

**기능:**
- PostFeed 컴포넌트 통합
- 배경색 #FAFAFA 설정

**코드 구조:**
```typescript
import PostFeed from '@/components/post/PostFeed';

export default function HomePage() {
  return (
    <div className="min-h-screen bg-background py-4">
      <PostFeed />
    </div>
  );
}
```

**스타일링:**
- 배경색: `bg-background` (#FAFAFA)
- 상하 여백: `py-4`

## 6. 유틸리티 함수

### 6.1 `lib/utils/time.ts` 생성/확인

**기능:**
- 상대 시간 포맷팅 함수
- 댓글 및 게시물 시간 표시용

**구현:**
```typescript
export function formatRelativeTime(dateString: string): string {
  const date = new Date(dateString);
  const now = new Date();
  const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);

  if (diffInSeconds < 60) return '방금 전';
  if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}분 전`;
  if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}시간 전`;
  if (diffInSeconds < 604800) return `${Math.floor(diffInSeconds / 86400)}일 전`;
  if (diffInSeconds < 2592000) return `${Math.floor(diffInSeconds / 604800)}주 전`;
  if (diffInSeconds < 31536000) return `${Math.floor(diffInSeconds / 2592000)}개월 전`;
  return `${Math.floor(diffInSeconds / 31536000)}년 전`;
}
```

## 7. 데이터베이스 쿼리 최적화

### 7.1 인덱스 확인

- `idx_posts_created_at`: 이미 생성됨 ✅
- `idx_posts_user_id`: 이미 생성됨 ✅
- `post_stats` 뷰: 이미 생성됨 ✅

### 7.2 쿼리 성능

- `post_stats` 뷰 사용으로 JOIN 최소화
- `LIMIT`과 `OFFSET`으로 페이지네이션
- 필요한 컬럼만 SELECT
- 좋아요 상태는 별도 쿼리로 조회 (배치 처리)

## 8. 에러 핸들링

### 8.1 API Route 에러 처리

- 인증 실패: 401 반환
- 데이터베이스 에러: 500 반환, 에러 로그 기록
- 잘못된 파라미터: 400 반환, 명확한 에러 메시지

### 8.2 클라이언트 에러 처리

- 네트워크 에러: 재시도 버튼 제공
- API 에러: 사용자 친화적 메시지 표시
- 빈 상태: "게시물이 없습니다" 메시지
- 로딩 상태: Skeleton UI 표시

## 9. 성능 최적화

### 9.1 이미지 최적화

- Next.js Image 컴포넌트 사용
- Lazy loading
- 적절한 sizes 속성 설정

### 9.2 무한 스크롤 최적화

- Intersection Observer 사용
- 불필요한 리렌더링 방지 (useCallback, useMemo)
- 스크롤 위치 유지 (선택적)

## 작업 순서

1. **유틸리티 함수 생성** (1단계)
   - `lib/utils/time.ts` 생성
   - `formatRelativeTime` 함수 구현

2. **API Route 생성** (2단계)
   - `app/api/posts/route.ts` 생성
   - GET 핸들러 구현
   - 인증 및 쿼리 파라미터 처리
   - 데이터베이스 쿼리 구현
   - 좋아요 상태 포함
   - 테스트

3. **PostCardSkeleton 생성** (3단계)
   - `components/post/PostCardSkeleton.tsx` 생성
   - Shimmer 효과 적용
   - PostCard와 동일한 레이아웃

4. **PostCard 컴포넌트 생성** (4단계)
   - `components/post/PostCard.tsx` 생성
   - 헤더 구현
   - 이미지 영역 구현
   - 액션 버튼 구현 (좋아요는 나중에)
   - 컨텐츠 영역 구현
   - 상대 시간 표시 함수 사용

5. **PostFeed 컴포넌트 생성** (5단계)
   - `components/post/PostFeed.tsx` 생성
   - 상태 관리 구현
   - 초기 데이터 로드 구현
   - 무한 스크롤 구현
   - 에러 처리 구현

6. **홈 페이지 업데이트** (6단계)
   - `app/(main)/page.tsx` 업데이트
   - PostFeed 통합

7. **스타일링 및 다듬기** (7단계)
   - Instagram 디자인에 맞게 스타일 조정
   - 반응형 확인
   - 애니메이션 추가 (선택적)

## 참고 파일

- [docs/PRD.md](docs/PRD.md) - PostCard 디자인 및 홈 피드 기능 정의 (106-156줄, 267-276줄)
- [docs/TODO.md](docs/TODO.md) - 홈 피드 페이지 TODO (64-85줄)
- [supabase/migrations/db.sql](supabase/migrations/db.sql) - 데이터베이스 스키마 (34-58줄, 145-162줄)
- [lib/types.ts](lib/types.ts) - TypeScript 타입 정의 (PostWithUser, PostWithStats)
- [lib/supabase/server.ts](lib/supabase/server.ts) - Supabase 서버 클라이언트

## 주의사항

1. **인증**: 모든 API 호출에서 Clerk 인증 확인 필수
2. **페이지네이션**: `limit` 최대값 제한 (50개)
3. **성능**: `post_stats` 뷰 사용으로 JOIN 최소화
4. **에러 처리**: 사용자 친화적 에러 메시지 필수
5. **로딩 상태**: Skeleton UI로 사용자 경험 개선
6. **무한 스크롤**: Intersection Observer로 성능 최적화
7. **이미지 최적화**: Next.js Image 컴포넌트 사용 필수
8. **상대 시간**: 한국어로 표시 ("3분 전", "1시간 전" 등)
9. **캡션 줄바꿈**: 2줄 초과 시 "더 보기" 기능 구현
10. **좋아요 상태**: API 응답에 `is_liked` 필드 포함

## 향후 확장 사항

- 좋아요 기능 통합 (4단계에서 구현 예정)
- 댓글 미리보기 통합 (6단계에서 구현 예정)
- 게시물 삭제 기능 (10단계에서 구현 예정)
- 더블탭 좋아요 (4단계에서 구현 예정)
